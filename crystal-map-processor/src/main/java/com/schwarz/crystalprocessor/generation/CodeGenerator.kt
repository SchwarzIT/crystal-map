package com.schwarz.crystalprocessor.generation

import com.schwarz.crystalcore.ICodeGenerator
import com.schwarz.crystalcore.ISettings
import com.schwarz.crystalcore.model.accessor.CblGenerateAccessorHolder
import com.schwarz.crystalprocessor.ProcessingContext
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.OriginatingElementsHolder
import java.io.File
import java.io.IOException
import javax.annotation.processing.Filer
import javax.tools.StandardLocation
import kotlin.io.path.createDirectories
import kotlin.io.path.isDirectory
import kotlin.io.path.notExists
import kotlin.io.path.outputStream

class CodeGenerator(private val filer: Filer) : ICodeGenerator {
    @Throws(IOException::class)
    override fun generate(
        entityToGenerate: FileSpec,
        settings: ISettings
    ) {
        ClassName(entityToGenerate.packageName, entityToGenerate.name).apply {
            ProcessingContext.createdQualifiedClazzNames.add(this)
        }

        val codePath = settings.kotlinGeneratedPath
        val fileWithHeader = entityToGenerate.toBuilder().addFileComment(HEADER).build()

        // used for kapt returns null for legacy annotationprocessor declarations
        if (codePath != null) {
            fileWithHeader.writeTo(File(codePath))
        } else {
            fileWithHeader.writeTo(filer)
        }
    }

    @Throws(IOException::class)
    override fun generateAndFixAccessors(
        entityToGenerate: FileSpec,
        generateAccessors: MutableList<CblGenerateAccessorHolder>,
        settings: ISettings
    ) {
        ClassName(entityToGenerate.packageName, entityToGenerate.name).apply {
            ProcessingContext.createdQualifiedClazzNames.add(this)
        }

        val codePath = settings.kotlinGeneratedPath
        val fileWithHeader = entityToGenerate.toBuilder().addFileComment(HEADER).build()

        val fixedFileString =
            generateAccessors.fold(fileWithHeader.toString()) { acc, generateAccessor ->
                if (generateAccessor.memberFunction != null && generateAccessor.memberFunction?.isSuspend == true) {
                    acc.replace(Regex("(${generateAccessor.memberFunction?.name}\\([^)]*\\)):\\s*Unit(\\s*=)"), "$1$2")
                } else {
                    acc
                }
            }

        // used for kapt returns null for legacy annotationprocessor declarations
        if (codePath != null) {
            val directory = File(codePath).toPath()
            require(directory.notExists() || directory.isDirectory()) {
                "path $directory exists but is not a directory."
            }
            val outputPath = directory.resolve(fileWithHeader.relativePath)
            outputPath.parent.createDirectories()
            outputPath.outputStream().bufferedWriter().use { it.write(fixedFileString) }
        } else {
            val originatingElements =
                fileWithHeader.members.asSequence()
                    .filterIsInstance<OriginatingElementsHolder>()
                    .flatMap { it.originatingElements.asSequence() }
                    .toSet()
            val filerSourceFile =
                filer.createResource(
                    StandardLocation.SOURCE_OUTPUT,
                    fileWithHeader.packageName,
                    "${fileWithHeader.name}.kt",
                    *originatingElements.toTypedArray()
                )
            try {
                filerSourceFile.openWriter().use { it.write(fixedFileString) }
            } catch (e: Exception) {
                try {
                    filerSourceFile.delete()
                } catch (ignored: Exception) {
                }
                throw e
            }
        }
    }

    companion object {
        private val HEADER = (
            "DO NOT EDIT THIS FILE.\n" +
                "Generated using Crystal-Map\n\n" +
                "Do not edit this class!!!!.\n"
            )
    }
}
