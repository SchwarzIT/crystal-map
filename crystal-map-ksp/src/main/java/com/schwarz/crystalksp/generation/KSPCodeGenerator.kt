package com.schwarz.crystalksp.generation

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.symbol.KSFile
import com.schwarz.crystalcore.ICodeGenerator
import com.schwarz.crystalcore.ISettings
import com.schwarz.crystalcore.model.accessor.CblGenerateAccessorHolder
import com.schwarz.crystalksp.ProcessingContext
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import java.io.IOException

class KSPCodeGenerator(private val generator: CodeGenerator) : ICodeGenerator {
    @Throws(IOException::class)
    fun generate(
        toGenerate: FileSpec,
        containingFile: List<KSFile>,
        aggregating: Boolean = false
    ) {
        ClassName(toGenerate.packageName, toGenerate.name).apply {
            ProcessingContext.createdQualifiedClassNames.add(this)
        }

        val fileWithHeader = toGenerate.toBuilder().addFileComment(HEADER).build()
        generator.createNewFile(
            Dependencies(aggregating, *containingFile.toTypedArray()),
            fileWithHeader.packageName,
            fileWithHeader.name
        )
            .writer()
            .use { fileWithHeader.writeTo(it) }
    }

    override fun generate(
        toGenerate: FileSpec,
        settings: ISettings
    ) {
        ClassName(toGenerate.packageName, toGenerate.name).apply {
            ProcessingContext.createdQualifiedClassNames.add(this)
        }

        val fileWithHeader = toGenerate.toBuilder().addFileComment(HEADER).build()
        generator.createNewFile(
            Dependencies(true),
            fileWithHeader.packageName,
            fileWithHeader.name
        )
            .writer()
            .use { fileWithHeader.writeTo(it) }
    }

    @Throws(IOException::class)
    override fun generateAndFixAccessors(
        entityToGenerate: FileSpec,
        generateAccessors: MutableList<CblGenerateAccessorHolder>,
        settings: ISettings
    ) {
        ClassName(entityToGenerate.packageName, entityToGenerate.name).apply {
            ProcessingContext.createdQualifiedClassNames.add(this)
        }

        val fileWithHeader = entityToGenerate.toBuilder().addFileComment(HEADER).build()

        val fixedFileString =
            generateAccessors.fold(fileWithHeader.toString()) { acc, generateAccessor ->
                if (generateAccessor.memberFunction != null && generateAccessor.memberFunction?.isSuspend == true) {
                    acc.replace(Regex("(${generateAccessor.memberFunction?.name}\\([^)]*\\)):\\s*Unit(\\s*=)"), "$1$2")
                } else {
                    acc
                }
            }

        generator.createNewFile(
            Dependencies(true),
            fileWithHeader.packageName,
            fileWithHeader.name
        )
            .writer()
            .use { it.write(fixedFileString) }

        // used for kapt returns null for legacy annotationprocessor declarations
//        if (codePath != null) {
//            val directory = File(codePath).toPath()
//            require(directory.notExists() || directory.isDirectory()) {
//                "path $directory exists but is not a directory."
//            }
//            val outputPath = directory.resolve(fileWithHeader.relativePath)
//            outputPath.parent.createDirectories()
//            outputPath.outputStream().bufferedWriter().use { it.write(fixedFileString) }
//        } else {
//            val originatingElements = fileWithHeader.members.asSequence()
//                .filterIsInstance<OriginatingElementsHolder>()
//                .flatMap { it.originatingElements.asSequence() }
//                .toSet()
//            val filerSourceFile = filer.createResource(
//                StandardLocation.SOURCE_OUTPUT,
//                fileWithHeader.packageName,
//                "${fileWithHeader.name}.kt",
//                *originatingElements.toTypedArray()
//            )
//            try {
//                filerSourceFile.openWriter().use { it.write(fixedFileString) }
//            } catch (e: Exception) {
//                try {
//                    filerSourceFile.delete()
//                } catch (ignored: Exception) {
//                }
//                throw e
//            }
//        }
    }

    companion object {
        private val HEADER = (
            "DO NOT EDIT THIS FILE.\n" +
                "Generated using Crystal-Map\n\n" +
                "Do not edit this class!!!!.\n"
            )
    }
}
